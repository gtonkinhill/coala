---
title: "Introduction to Coala"
author: "Paul Staab"
date: "coala `r packageVersion('coala')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

Coalescent simulation referrers to the idea to simulate the evolution of 
biological sequences like DNA by tracing their ancestry back in time. The
`coala` package is an interface for calling a number of commonly used
coalescent simulators from R.

# Creating a model
Use the function `coal_model` to create a basic coalescent model:

```{r}
library(coala)
model <- coal_model(sample_size = 3, loci_number = 1)
```

This creates a basic model with one population of constant size.
Simulated is one genetic locus in 3 haplotypes taken from the population. 

Printing the model gives a short summary of this content:
```{r}
print(model)
```

Models consist of 

* _features_, which represent evolutionary forces and events present in the 
  model, 
* _parameters_, which are the model parameters, 
* _loci_, which describe the genetic regions that are simulated and 
* _summary statistics_, which describe the format of the simulated data.

In order to simulate the model we need to add a few more features and at least
one summary statistic.


# Adding features
For simulating sequences, we need to add mutations to the model. To do so,
we create a corresponding feature using `feat_mutation` and add it to the
existing model using the plus operator:

```{r}
model <- model + feat_mutation(rate = 1, model = "IFS")
model
```

Now, mutation occur with rate 1 and according to an infinite-sites mutation 
model (IFS). Details on both rate and mutation model are given the help
page of the feature (`?feat_mutation`). 

coala currently support the features

```{r echo=FALSE}
funcs <- ls("package:coala")
funcs[grep("^feat_", funcs)]
```

However, not all combination of all features might be possible. Please refer 
to the features help pages for detailed information.


# Adding Summary Statistics

Adding summary statistics works in a similar fashion as adding features:

```{r}
model <- model + sumstat_seg_sites()
model
```

This adds the _segregating sites_ summary statistic to the model, which is a
basic summary statistic in population genetics. Again, refer to 
`?sumstat_seg_sites` for details.

Available summary statistics are:

```{r echo=FALSE}
funcs[grep("^sumstat_", funcs)]
```



# Simulating the model

We now can simulate the model. The printed output of a model contains information
which program will be used for the simulation and which arguments will be used.
As coala is in a early stage, please make sure to always check both. 

The
function `simulate` will call the program with the printed options, parse its
output and calculated the added summary statistics:

```{r}
set.seed(123)
sumstats <- simulate(model)
```

The returned object `sumstats` a list, in which each entry corresponds to one 
summary statistic. As there is only one summary statistic in our model, 
it has only one entry:

```{r}
names(sumstats)
```

The structure in `sumstats$seg_sites` is given by the segregating sites 
statistic. It is again a list, where each entry represents one locus. For each 
locus, it contains a matrix as specified in `?sumstat_seg_sites`:

```{r}
sumstats$seg_sites[[1]]
```


# Adding Loci
If we want to have more loci in a model, we can add them using the `locus_` 
functions. The most basic option is to add an additional locus with a different
length:

```{r}
model <- model + locus_single(500)
model
```

Now you model consists of two loci, the first with length 1000, the second with
500. Simulation now produces a seg. sites list with two entries corresponding 
to the loci:

```{r}
sumstats <- simulate(model)
sumstats$seg_sites[[1]]
sumstats$seg_sites[[2]]
```

Another possibility is to add multiple loci with the same length using 
`locus_averaged`, which gives better performance than adding the loci 
one by one. For example
```{r}
model <- model + locus_averaged(2, 750)
sumstats <- simulate(model)
length(sumstats$seg_sites)
```
adds two more loci with length of 750bp to the model.



# Adding Parameters
So far, we have used a model without parameters that can vary between 
simulations. In particular for fitting a model to data via ABC or Jaatha it is 
useful to such parameters so that you don't need to create a new model for
each simulation.


### Named Parameters



### Parameters with Priors
A parameter distributed according to a prior can be specified using the 
`par_prior` function. The functions first argument is a name for the parameter,
the second an expression that when evaluated produces a sample from the
prior distribution.

TODO: Implement + Example



### Parameter Ranges
For Jaatha, you need to give a range of possible values for each parameters.
This is done using `par_range`. For instance

```{r}
model <- model + feat_recombination(rate = par_range("rho", .1, 2))
```

adds recombination with a rate of "rho" to the model, which can be between
_0.1_ and _2_. For ranged parameters, the actual value used in a simulation
needs to be specified when simulating:

```{r}
sumstats <- simulate(model, pars = c(rho = 1.5))
```


### Expressions
Finally, there is a very powerful type of parameters generated with `par_expr`.
Similar to parameters with priors, the value of the parameter is given as an
R expression, which is evaluated before simulation. Different to `par_prior`,
this expression can contain other named parameters. For example 

```{r}
model <- coal_model(4, 2) +
  feat_mutation(rate = par_range("theta", .1, 5)) +
  feat_recombination(rate = par_expr(theta * 2))
```

creates a model with a mutation rate between .1 and 5 and a recombination
rate that always is twice as high. 
